import { NextResponse } from 'next/server';
import { getSession } from '@/lib/auth';
import { createProject, createApplication, deployApplication } from '@/lib/coolify';

var ANTHROPIC_KEY = process.env.ANTHROPIC_API_KEY || '';
var GITHUB_TOKEN = process.env.GITHUB_TOKEN || '';
var GITHUB_USER = process.env.GITHUB_USERNAME || '';
var SERVER_UUID = 'hsgg40gscs8kcs8scwwko0ws';
var DEST_UUID = 'zgog0wg4wksoc44k840s0co0';

export async function POST(req) {
  var session = await getSession();
  if (!session) return NextResponse.json({ error: 'Unauthorized' }, { status: 401 });

  try {
    var body = await req.json();
    var prompt = body.prompt;
    var projectName = body.name || 'ai-site';
    var slug = projectName.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '');
    var repoName = 'kumo-' + slug;

    // Step 1: Generate code with Claude
    var code = await generateWithClaude(prompt, projectName);

    // Step 2: Create GitHub repo and push code
    var repoUrl = await createGithubRepo(repoName, code);

    // Step 3: Create Coolify project and deploy
    var project = await createProject({ name: projectName, description: projectName });
    var app = await createApplication({
      project_uuid: project.uuid,
      environment_name: 'production',
      server_uuid: SERVER_UUID,
      destination_uuid: DEST_UUID,
      type: 'public',
      name: projectName,
      description: projectName,
      git_repository: repoUrl,
      git_branch: 'main',
      build_pack: 'nixpacks',
      ports_exposes: '3000',
    });

    try { await deployApplication(app.uuid); } catch (e) { console.log('Deploy trigger:', e.message); }

    return NextResponse.json({
      success: true,
      application: app,
      repository: repoUrl,
      uuid: app.uuid,
    });
  } catch (err) {
    console.error('Generate error:', err);
    return NextResponse.json({ error: err.message }, { status: 500 });
  }
}

async function generateWithClaude(prompt, name) {
  var systemPrompt = "You are a web developer. Generate a complete Next.js project. Return ONLY a JSON object with file paths as keys and file contents as values. No markdown, no explanation, just the JSON.\n\nAlways include these files:\n- package.json (with next, react, react-dom dependencies)\n- next.config.js\n- app/layout.js\n- app/page.js\n- app/globals.css\n\nUse Next.js App Router (app/ directory). Use inline styles or a single globals.css. Make the design modern, professional, and mobile-responsive. Use a dark theme with accent colors unless specified otherwise. Include real placeholder content, not lorem ipsum.";

  var res = await fetch('https://api.anthropic.com/v1/messages', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'x-api-key': ANTHROPIC_KEY,
      'anthropic-version': '2023-06-01',
    },
    body: JSON.stringify({
      model: 'claude-sonnet-4-20250514',
      max_tokens: 8000,
      messages: [
        { role: 'user', content: 'Create a website for: ' + prompt + '\n\nProject name: ' + name + '\n\nReturn ONLY valid JSON with file paths as keys and contents as values. No markdown fences. Example format: {"package.json": "...", "app/page.js": "..."}' }
      ],
      system: systemPrompt,
    }),
  });

  if (!res.ok) {
    var errText = await res.text();
    throw new Error('Claude API error: ' + errText);
  }

  var data = await res.json();
  var text = data.content[0].text;

  // Clean up response - remove markdown fences if present
  text = text.replace(/```json\s*/g, '').replace(/```\s*/g, '').trim();

  var files;
  try {
    files = JSON.parse(text);
  } catch (e) {
    // Try to extract JSON from the response
    var match = text.match(/\{[\s\S]*\}/);
    if (match) {
      files = JSON.parse(match[0]);
    } else {
      throw new Error('Failed to parse generated code');
    }
  }

  return files;
}

async function createGithubRepo(repoName, files) {
  // Create repo
  var createRes = await fetch('https://api.github.com/user/repos', {
    method: 'POST',
    headers: {
      'Authorization': 'token ' + GITHUB_TOKEN,
      'Content-Type': 'application/json',
      'Accept': 'application/vnd.github.v3+json',
    },
    body: JSON.stringify({
      name: repoName,
      private: false,
      auto_init: false,
      description: 'Generated by Kumo AI',
    }),
  });

  if (!createRes.ok) {
    var err = await createRes.json();
    // If repo exists, try to use it
    if (err.errors && err.errors[0] && err.errors[0].message === 'name already exists on this account') {
      // Delete existing files and re-push
    } else {
      throw new Error('GitHub repo creation failed: ' + JSON.stringify(err));
    }
  }

  // Build tree of files
  var fileEntries = Object.entries(files);
  var treeItems = [];

  for (var i = 0; i < fileEntries.length; i++) {
    var filePath = fileEntries[i][0];
    var content = fileEntries[i][1];

    // Create blob
    var blobRes = await fetch('https://api.github.com/repos/' + GITHUB_USER + '/' + repoName + '/git/blobs', {
      method: 'POST',
      headers: {
        'Authorization': 'token ' + GITHUB_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ content: content, encoding: 'utf-8' }),
    });

    if (!blobRes.ok) throw new Error('Failed to create blob for ' + filePath);
    var blob = await blobRes.json();

    treeItems.push({
      path: filePath,
      mode: '100644',
      type: 'blob',
      sha: blob.sha,
    });
  }

  // Also add .gitignore
  var gitignoreBlob = await fetch('https://api.github.com/repos/' + GITHUB_USER + '/' + repoName + '/git/blobs', {
    method: 'POST',
    headers: {
      'Authorization': 'token ' + GITHUB_TOKEN,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ content: 'node_modules\n.next\n.env\n.env.local\n', encoding: 'utf-8' }),
  }).then(function(r) { return r.json(); });

  treeItems.push({ path: '.gitignore', mode: '100644', type: 'blob', sha: gitignoreBlob.sha });

  // Create tree
  var treeRes = await fetch('https://api.github.com/repos/' + GITHUB_USER + '/' + repoName + '/git/trees', {
    method: 'POST',
    headers: {
      'Authorization': 'token ' + GITHUB_TOKEN,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({ tree: treeItems }),
  });

  if (!treeRes.ok) throw new Error('Failed to create tree');
  var tree = await treeRes.json();

  // Create commit
  var commitRes = await fetch('https://api.github.com/repos/' + GITHUB_USER + '/' + repoName + '/git/commits', {
    method: 'POST',
    headers: {
      'Authorization': 'token ' + GITHUB_TOKEN,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      message: 'Generated by Kumo AI',
      tree: tree.sha,
    }),
  });

  if (!commitRes.ok) throw new Error('Failed to create commit');
  var commit = await commitRes.json();

  // Create main branch ref
  var refRes = await fetch('https://api.github.com/repos/' + GITHUB_USER + '/' + repoName + '/git/refs', {
    method: 'POST',
    headers: {
      'Authorization': 'token ' + GITHUB_TOKEN,
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      ref: 'refs/heads/main',
      sha: commit.sha,
    }),
  });

  // If ref already exists, update it
  if (!refRes.ok) {
    await fetch('https://api.github.com/repos/' + GITHUB_USER + '/' + repoName + '/git/refs/heads/main', {
      method: 'PATCH',
      headers: {
        'Authorization': 'token ' + GITHUB_TOKEN,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ sha: commit.sha, force: true }),
    });
  }

  return 'https://github.com/' + GITHUB_USER + '/' + repoName;
}
